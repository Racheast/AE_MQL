package util.MMGenerators.QMMGenerator;

public class EClassMethodBodies {
	public static final String ROOTCLASS_VALIDATIONOPERATION_BODY = "if(diagnostic!=null){"
			+ "\n    if(this.evaluationOperator != null){"
			+ "\n    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);"
			+ "\n    	for(int i=0; i<diagnosticList.size(); i++){"
			+ "\n    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));"
			+ "\n    	}"
			+ "\n    }"
			+ "\n}";
	
	public static final String ROOTCLASS_VALIDATEALLCHECKEXPRESSIONS_BODY = "\n	EList<qmm.Operator> operators = (EList<qmm.Operator>)o;"
			+ "\n	EList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n	if(operators != null){"
			+ "\n		for(qmm.Operator operator:operators){"
			+ "\n			diagnosticList.addAll(validateCheckExpression(operator));"
			+ "\n		}"
			+ "\n   }"
			+ "\n	return diagnosticList;";
	
	public static final String ROOTCLASS_VALIDATECHECKEXPRESSION_BODY = "EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();"  
			+ "\nEClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();"
			+ "\nEClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();"
			+ "\nqmm.Operator operator = (qmm.Operator)o;"
			+ "\nEList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n"
			+ "\nif(functionalOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();"
			+ "\n    	EClass lastOperatorType = (EClass)lastOperator.getType();"
			+ "\n    	if(!booleanType.isSuperTypeOf(lastOperatorType)){"
			+ "\n			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";"
			+ "\n    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ "\n    	}"	
			+ "\n}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){"
			+ "\n    	diagnosticList.addAll(validateCheckExpression(op));"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn diagnosticList;";
	
	public static final String REGULAR_ATTRIBUTE_ECLASS_VALIDATECHECKEXPRESSION_BODY = "EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();"  
			+ "\nEClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();"
			+ "\nEClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();"
			+ "\nqmm.Operator operator = (qmm.Operator)o;"
			+ "\nEList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n"
			+ "\nif(functionalOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();"
			+ "\n    	EClass lastOperatorType = (EClass)lastOperator.getType();"
			+ "\n    	if(!booleanType.isSuperTypeOf(lastOperatorType)){"
			+ "\n			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";"
			+ "\n    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ "\n    	}"	
			+ "\n}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){"
			+ "\n    	diagnosticList.addAll(validateCheckExpression(op));"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn diagnosticList;";
	
	public static final String TYPED_CALCULATEABLE_ELEMENT_REFERENCE_ARGUMENT_VALIDATIONOPERATION_BODY = "qmm.RootClass containingRootClass = null;"
			+ 	"\nqmm.RootClass referencesRootClass = null;"
			+ 	"\nqmm.AttributeEClass containingAttributeEClass = null;"
			+ 	"\nqmm.AttributeEClass referencesAttributeEClass = null;"
			+	"\nif(this.eContainer() != null && this.reference != null){"
			+ 	"\n		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();"
			+ 	"\n"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			if(eContainer instanceof qmm.AttributeEClass){"
			+ 	"\n				containingAttributeEClass = (qmm.AttributeEClass)eContainer;"
			+ 	"\n			}"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n		containingRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"
			+ 	"\n		eContainer = this.reference.eContainer();"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n"
			+ 	"\n		referencesRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;"
			+ 	"\n"
			+ 	"\n		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !"
			+ 	"\n			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+	"\n"
			+ 	"\n		if(containingRootClass != referencesRootClass){"
			+ 	"\n			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+	"\n"
			+	"\n		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));"
			+	"\n"
			+	"\n}"
			+ 	"\nreturn true;";
	
	public static final String TYPED_REGULAR_ATTRIBUTE_ECLASS_VALIDATIONOPERATION_BODY = "super.validate(diagnostic, context);"
			+ "\nif(diagnostic!=null){"
			+ "\n    if(this.operator != null){"
			+ "\n    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);"
			+ "\n    	for(int i=0; i<diagnosticList.size(); i++){"
			+ "\n    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));"
			+ "\n    	}"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn true;";
	
	public static final String TYPED_ELEMENT_GETTYPE_BODY  = "EClass typeEClass = QmmPackage.eINSTANCE.getType();"
			+ "\n    EClass type = null;"
			+ "\n    for(EClass possibleTypeSubClass : this.eClass().getEAllSuperTypes()){"
			+ "\n    	if(typeEClass.isSuperTypeOf(possibleTypeSubClass) && !typeEClass.equals(possibleTypeSubClass)){"
			+ "\n    		type = possibleTypeSubClass;"
			+ "\n    	}"
			+ "\n    }"
			+ "\n    return type;";
	
	public static final String FUNCTIONAL_OPERATOR_GETLASTOPERATOR_BODY = "qmm.FunctionalOperator operator = this;"
			+ "\nwhile(operator.eGet(operator.eClass().getEStructuralFeature(\"operator\")) != null){"
			+ "\n    operator = (qmm.FunctionalOperator) operator.eGet(operator.eClass().getEStructuralFeature(\"operator\"));"
			+ "\n}"
			+ "\nreturn operator;";
	
	public static final String COUNTABLE_REFERENCE_ARGUMENT_VALIDATIONOPERATION_BODY = "qmm.RootClass containingRootClass = null;"
			+ 	"\nqmm.RootClass referencesRootClass = null;"
			+ 	"\nqmm.Countable containingCountable = null;"
			+ 	"\n"
			+	"\nif(this.reference != null){"
			+	"\n		if(this.reference instanceof qmm.Reference_OrGroup){"
			+	"\n			qmm.Reference_OrGroup rog = (qmm.Reference_OrGroup)this.reference;"
			+	"\n			EList<org.eclipse.emf.ecore.EObject> references = (EList<org.eclipse.emf.ecore.EObject>)rog.eGet(rog.eClass().getEStructuralFeature(\"reference\"));"
			+	"\n			if(references.size()>0){"
			+	"\n				String errorMessage = \"Element \" + rog.getName() + \" is a concretized non-containment reference. It's not possible to use concretized non-containment references in evaluation operations in this prototype. Please remove ': ...' after the declaration of element \" + rog.getName() + \", if you want to use \" + rog.getName() + \" in the evaluation operation.\";"
			+	"\n				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.COUNTABLE_REFERENCE_ARGUMENT__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n			}"
			+	"\n		}"
			+	"\n		if(this.eContainer() != null){"
			+ 	"\n			org.eclipse.emf.ecore.EObject eContainer = this.eContainer();"
			+ 	"\n			while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n				if(eContainer instanceof qmm.Countable){"
			+ 	"\n					containingCountable = (qmm.Countable)eContainer;"
			+ 	"\n				}"
			+ 	"\n				eContainer = eContainer.eContainer();"
			+ 	"\n			}"
			+ 	"\n			containingRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"	
			+ 	"\n			eContainer = this.reference.eContainer();"
			+ 	"\n			while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n				eContainer = eContainer.eContainer();"
			+ 	"\n			}"
			+ 	"\n"
			+ 	"\n			referencesRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"
			+ 	"\n			if(containingCountable != null && containingCountable == reference){  //self-reference in expression !"
			+ 	"\n				String errorMessage = \"Self-reference in expression of \" + containingCountable + \" detected. Self-references are not allowed!\";"
			+ 	"\n				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.COUNTABLE_REFERENCE_ARGUMENT__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n			}"
			+ 	"\n"
			+ 	"\n			if(containingRootClass != referencesRootClass){"
			+ 	"\n				String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";"
			+ 	"\n				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.COUNTABLE_REFERENCE_ARGUMENT__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n			}"
			+	"\n"
			+	"\n			if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated()){"
			+ 	"\n 				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.COUNTABLE_REFERENCE_ARGUMENT__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));"
			+	"\n			}"
			+	"\n		}"
			+	"\n}"
			+	"\n"
			+ 	"\nreturn true;";
	
	public static final String ORGROUP_VALIDATIONOPERATION_BODY = "EClass containerEClass = this.eContainingFeature().getEContainingClass();"
			+	"\nif(containerEClass != null){"
			+	"\n		org.eclipse.emf.ecore.EStructuralFeature containment = this.eClass().getEStructuralFeature(\"containment\");"
			+	"\n		if(containment != null){"
			+	"\n			org.eclipse.emf.ecore.EClassifier eType	= containment.getEType();"
			+	"\n			if(eType != null && eType instanceof EClass){"
			+	"\n				EClass typeEClass = (EClass)eType;"
			+	"\n				if(!containerEClass.isSuperTypeOf(typeEClass) && this.transitive){"
			+	"\n					String errorMessage = \"Feature \" + this.getName() + \" can't be transitive! It is defined by the type \" + containerEClass.getName() + \", but is itself not an instance of (a subtype of) this type.\";"
			+	"\n					diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OR_GROUP__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n				}"
			+	"\n			}"
			+	"\n		}"
			+	"\n}"
			+	"\n"
			+	"\nreturn true;";
	
	public static final String CONCRETE_REFERENCEORGROUP_VALIDATIONOPERATION_BODY = "super.validate(diagnostic, context);"
			+	"\n		java.util.ArrayList<org.eclipse.emf.ecore.EObject> thisContainers = new java.util.ArrayList<org.eclipse.emf.ecore.EObject>();"
			+	"\n		org.eclipse.emf.ecore.EObject thisContainer = this.eContainer();"
			+	"\n"
			+ 	"\n		while(thisContainer != null){"
			+	"\n			thisContainers.add(thisContainer);"
			+	"\n			thisContainer = thisContainer.eContainer();"
			+	"\n		}"
			+	"\n"
			+	"\n		for(qmm.RootClass rc: this.reference){"
			+ 	"\n			org.eclipse.emf.ecore.EObject eContainer = rc.eContainer();"
			+ 	"\n			while(eContainer != null && !thisContainers.contains(rc)){"
			+	"\n				if(eContainer instanceof qmm.Containment_OrGroup){"
			+ 	"\n					EList containment = (EList)eContainer.eGet(eContainer.eClass().getEStructuralFeature(\"containment\"));"
			+ 	"\n"
			+	"\n					if(rc == this.eContainer) break;"
			+ 	"\n"
			+	"\n					if(containment.size() > 1){"
			+	"\n						String errorMessage = rc.getName() + \" is defined within an alternative Or-branch of node \" + ((qmm.OrGroup)eContainer).getName() + \". It's not possible to reference nodes that are defined in alternative Or-branches.\";"
			+	"\n						diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OR_GROUP__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n					}"
			+	"\n				}"
			+ 	"\n				if(eContainer instanceof qmm.OrGroup && ((qmm.OrGroup)eContainer).isNegated()){"
			+	"\n						if(!thisContainers.contains(eContainer)){"		
			+	"\n							String errorMessage = rc.getName() + \" is a negated pattern or is defined within a negated pattern. It's not possible to reference nodes that are negated or are defined within negated patterns.\";"
			+	"\n							diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OR_GROUP__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n						}"
			+ 	"\n				}"
			+	"\n				eContainer = eContainer.eContainer();"
			+	"\n			}"
			+	"\n		}"
			+	"\nreturn true;";
	
	public static final String REFERENCE_VALIDATIONOPERATION_BODY 	= "EClass containerEClass = this.eContainingFeature().getEContainingClass();"
			+	"\nif(containerEClass != null){"
			+	"\n	org.eclipse.emf.ecore.EObject orGroup = (org.eclipse.emf.ecore.EObject)this.eGet(this.eClass().getEStructuralFeature(\"orGroup\"));"
			+	"\n	if(orGroup != null){"
			+	"\n		org.eclipse.emf.ecore.EStructuralFeature containment = orGroup.eClass().getEStructuralFeature(\"containment\");"
			+	"\n		if(containment != null){"
			+	"\n			org.eclipse.emf.ecore.EClassifier eType	= containment.getEType();"
			+	"\n			if(eType != null && eType instanceof EClass){"
			+	"\n				EClass typeEClass = (EClass)eType;"
			+	"\n				if(!containerEClass.isSuperTypeOf(typeEClass) && this.transitive){"
			+	"\n					String errorMessage = \"Feature \" + this.eContainingFeature().getName() + \" can't be transitive! It is defined by the type \" + containerEClass.getName() + \", but is itself not an instance of (a subtype of) this type.\";"
			+	"\n					diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.REFERENCE_OBJECT__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n				}"
			+	"\n			}"
			+	"\n		}"
			+	"\n	}"
			+	"\n}"
			+	"\n"
			+	"\nreturn true;";
	
	public static final String SELECTCLAUSE_VALIDATIONOPERATION_BODY = "for(qmm.NamedElement n : namedElements){"
			+	"\n			if(n instanceof qmm.NegatableElement && ((qmm.NegatableElement)n).isNegated()){"
			+	"\n				String errorMessage = n.getName() + \" is negated. It is not possible to select negated elements\";"
			+	"\n				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.SELECT_CLAUSE__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n			}"
			+ 	"\n			org.eclipse.emf.ecore.EObject eContainer = n.eContainer();"
			+ 	"\n			while(eContainer != null){"
			+	"\n				if(eContainer instanceof qmm.Containment_OrGroup){"
			+ 	"\n					EList containment = (EList)eContainer.eGet(eContainer.eClass().getEStructuralFeature(\"containment\"));"
			+	"\n					if(containment.size() > 1){"
			+	"\n						String errorMessage = n.getName() + \" is defined within an Or-branch of node \" + ((qmm.OrGroup)eContainer).getName() + \". It's atm not possible to reference nodes that are defined in Or-branches of other nodes.\";"
			+	"\n						diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.SELECT_CLAUSE__VALIDATE, errorMessage,new Object[] { this }));"
			+	"\n					}"
			+	"\n				}"
			+ 	"\n				if(eContainer instanceof qmm.OrGroup && ((qmm.OrGroup)eContainer).isNegated()){"
			+	"\n						String errorMessage = n.getName() + \" is a negated pattern or is defined within a negated pattern. It's not possible to reference nodes that are negated or are defined within negated patterns.\";"
			+	"\n						diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.SELECT_CLAUSE__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n				}"
			+	"\n				eContainer = eContainer.eContainer();"
			+	"\n			}"
			+	"\n		}"
			+	"\nreturn true;";
	
	public static final String NAMEDELEMENT_VALIDATIONOPERATION_BODY 	= 	"if(this.name != null){"
																		+	"\n		if(this.name.equals(\"elem\")){"
																		+ 	"\n			String errorMessage=\"The name can't be 'elem'. 'elem' is a reserved literal.\";"
																		+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.SELECT_CLAUSE__VALIDATE, errorMessage,new Object[] { this }));"
																		+	"\n		}"
																		+ 	"\n"
																		+ 	"\n		if(this.name.startsWith(\"query_\")){"
																		+ 	"\n			String errorMessage=\"The name can't start with 'query_'. 'query_' is a reserved literal prefix.\";"
																		+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.SELECT_CLAUSE__VALIDATE, errorMessage,new Object[] { this }));"
																		+	"\n		}"
																		+	"\n}"
																		+ 	"\nreturn true;";

	
	public static String write_Reference_UpperBoundCheckerValidationBody(String containerEClassName, String referenceName, int upperBound){
		String body = "final int " + referenceName + "_upperBound = " + upperBound + ";"
				  	+	"\nint nr_nonTransitive_" + referenceName + " = " + 0 + ";"
				  	+	"\nif(this." + referenceName + " != null){"
				  	+	"\n		for(qmm.OrGroup og : this." + referenceName + ") if(!og.isTransitive() && !og.isNegated() && !og.isGeneralized()) nr_nonTransitive_" + referenceName + "++;"
				  	+	"\n}"
				  	+	"\nif(nr_nonTransitive_" + referenceName + " > " + referenceName + "_upperBound && " + referenceName + "_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"" + containerEClassName + " contains \" + nr_nonTransitive_" + referenceName + " + \" non-transitive, non-negated and non-generalized " + referenceName + "(s). Only \" + " + referenceName + "_upperBound + \" non-transitive, non-negated and non-generalized " + referenceName + "(s) are allowed.\",new Object[] { this }));";
		
		return body;
	}
	
	public static String write_AttributeEClass_UpperBoundCheckerValidationBody(String containerEClassName, String referenceName, int upperBound){
		String referenceName_short = referenceName.substring(0, referenceName.indexOf("_AttrEClass"));
		String body = "final int " + referenceName + "_upperBound = " + upperBound + ";"
			  	+	"\nint nr_nonGeneralized_" + referenceName + " = " + 0 + ";"
			  	+	"\nif(this." + referenceName + " != null){"
			  	+	"\n		for(qmm.RegularAttributeEClass attr : this." + referenceName + ") if(!attr.isGeneralized() && !attr.isNegated()) nr_nonGeneralized_" + referenceName + "++;"
			  	+	"\n}"
			  	+	"\nif(nr_nonGeneralized_" + referenceName + " > " + referenceName + "_upperBound && " + referenceName + "_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"" + containerEClassName + " contains \" + nr_nonGeneralized_" + referenceName + " + \" non-generalized and non-negated " + referenceName_short + "(s). Only \" + " + referenceName + "_upperBound + \" non-generalized and non-negated " + referenceName_short + "(s) are allowed.\",new Object[] { this }));";
	
	return body;
	}
}
